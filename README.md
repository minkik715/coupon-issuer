# coupon-issuer

    /*
    스프링은 자체적으로 스레드 풀을 가지고 있어 request가 들어오면
    스레드를 스레드 풀에서 꺼내서 사용하게 한다.
    즉 짧은 시간내에 많은 요청을 들어오면
    coupon이 save 되기전에 여러개의 count를 셀 수 있게 된다.
    즉 여러 쓰레드에서 count가 같을 수 있다는 것이다. 그러면 쿠폰 발급을 초과할 수있는 큰 문제를 야기할 수 있게 된다.
    따라서 이 동시성 문제를 해결하기 위해 여러가지 방법이 있을 수 있다.
    첫번 째로 비관적 락을 걸어 coupon 을 읽고 업데이트 하는 동안 다른 쓰레드에서 접근하지 못하게 락을 거는 방법이 있다. 
    둘 째로 sync를 사용하여 하나의 쓰레드에서만 해당 함수를 접근 할 수 있게 한다.
    셋 째로 낙관적 락을 걸어 update version을 사용하는 것이다.
    위 방법들은 짧은 시간내에 많은 요청이들어오는 선착순 쿠폰 발급을 하기에는 성능 문제가 있다.
    락의 범위 넓어 발급이 느려지고, sync를 사용하게되면 싱글쓰레드 처럼 사용되기 떄문에 이 또한 발급이 느려지게된다. 
    따라서 이 문제를 해결하기 위해 redis를 사용하는 것이다 redis는 싱글 쓰레드를 사용하는데  coupon count를 incr해주는 것이다 redis의 icre는 성능이 굉장히 빠른 편이다.
    하지만 현재 코드는 rdb의 insert를 할경우 많은 부하를 일으키거나 db를 사용하는 다른 api에 effect를 줄 수 있기 때문에 문제 해결을 위해 무언가가 필요하다.
    따라서 coupoun을 발급하는 과정과, 쿠폰을 저장하는 과정을 나눠 
    카프카를 사용하여 coupon 발급을 publish 하면 consumer service에서 이를 소비하여 쿠폰을 저장해주는 방식이다. 
    사용자에게 쿠폰 발급과 저장에 시간차가 있음을 고지하면 된다. good
     */
